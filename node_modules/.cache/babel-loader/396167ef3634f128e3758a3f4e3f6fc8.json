{"ast":null,"code":"export const convertXml = dataFromForm => {\n  let headers = getHeaders(formToArray(dataFromForm) || []);\n  console.log(toCSVarray(formToArray(dataFromForm) || []));\n};\n\nconst formToArray = dataFromForm => {\n  var _xmlDoc$getElementsBy;\n\n  var xmlParser = new DOMParser();\n  var xmlDoc = xmlParser.parseFromString(dataFromForm, \"text/xml\");\n  return (_xmlDoc$getElementsBy = xmlDoc.getElementsByTagName(\"CSVIntervalData\")[0].textContent) === null || _xmlDoc$getElementsBy === void 0 ? void 0 : _xmlDoc$getElementsBy.split(\"\\n\");\n}; //get the header row which contains 100\n\n\nconst getHeaders = xmlDocArr => {\n  let headers;\n  xmlDocArr.forEach(row => {\n    if (row.includes(\"100\")) headers = row.split(\",\");\n  });\n  return headers;\n};\n\nconst toCSVarray = unformattedRows => {\n  let CSVArray;\n  let seperatedData = seperateRowsToChunks(unformattedRows);\n  CSVArray = seperatedData; //to be changed\n\n  return CSVArray;\n}; //seperate the rows by the line which contains 200\n\n\nconst seperateRowsToChunks = unformattedRows => {\n  let chunks = [];\n  let quickPointer = 0;\n  let slowPointer = 0;\n  let validatedRows = validateRows(unformattedRows);\n  validatedRows.forEach((row, i) => {\n    if (row.startsWith(\"200\") || row.includes(\"900\")) {\n      if (quickPointer === 0) {\n        quickPointer = i;\n        slowPointer = i + 1; // to make sure it contains at least 1 row for each 200\n      } else if (i - slowPointer > 1) {\n        quickPointer = i;\n        chunks.push(unformattedRows.slice(slowPointer, quickPointer));\n        slowPointer = i + 1;\n      }\n    }\n  });\n  return chunks;\n}; //to check whether the row is validate\n\n\nconst validateRows = unformattedRows => {\n  let validatedRows = unformattedRows.filter(row => row.startsWith(\"100\") || row.startsWith(\"200\") || row.startsWith(\"300\") || row.startsWith(\"900\"));\n  return validatedRows;\n}; // var A = [[\"n\", \"sqrt(n)\"]];\n// for (var j: number = 1; j < 10; ++j) {\n// \tA.push([j.toString(), Math.sqrt(j).toString()]);\n// }\n// var csvRows = [];\n// for (var i = 0, l = A.length; i < l; ++i) {\n// \tcsvRows.push(A[i].join(\",\"));\n// }\n// var csvString = csvRows.join(\"%0A\");\n// var a = document.createElement(\"a\");\n// a.href = \"data:attachment/csv,\" + encodeURIComponent(csvString);\n// a.target = \"_blank\";\n// a.download = \"myFile.csv\";\n// document.body.appendChild(a);\n// a.click();","map":{"version":3,"sources":["/Users/shuyun/Desktop/vscode/xml-to-csv/UI/src/services/convertXml.tsx"],"names":["convertXml","dataFromForm","headers","getHeaders","formToArray","console","log","toCSVarray","xmlParser","DOMParser","xmlDoc","parseFromString","getElementsByTagName","textContent","split","xmlDocArr","forEach","row","includes","unformattedRows","CSVArray","seperatedData","seperateRowsToChunks","chunks","quickPointer","slowPointer","validatedRows","validateRows","i","startsWith","push","slice","filter"],"mappings":"AAAA,OAAO,MAAMA,UAAU,GAAIC,YAAD,IAA0B;AACnD,MAAIC,OAAO,GAAGC,UAAU,CAACC,WAAW,CAACH,YAAD,CAAX,IAA6B,EAA9B,CAAxB;AACAI,EAAAA,OAAO,CAACC,GAAR,CAAYC,UAAU,CAACH,WAAW,CAACH,YAAD,CAAX,IAA6B,EAA9B,CAAtB;AACA,CAHM;;AAKP,MAAMG,WAAW,GAAIH,YAAD,IAA0B;AAAA;;AAC7C,MAAIO,SAAS,GAAG,IAAIC,SAAJ,EAAhB;AACA,MAAIC,MAAM,GAAGF,SAAS,CAACG,eAAV,CAA0BV,YAA1B,EAAwC,UAAxC,CAAb;AACA,kCAAOS,MAAM,CACXE,oBADK,CACgB,iBADhB,EACmC,CADnC,EAELC,WAFF,0DAAO,sBAEQC,KAFR,CAEc,IAFd,CAAP;AAGA,CAND,C,CAQA;;;AACA,MAAMX,UAAU,GAAIY,SAAD,IAAyB;AAC3C,MAAIb,OAAJ;AACAa,EAAAA,SAAS,CAACC,OAAV,CAAmBC,GAAD,IAAS;AAC1B,QAAIA,GAAG,CAACC,QAAJ,CAAa,KAAb,CAAJ,EAAyBhB,OAAO,GAAGe,GAAG,CAACH,KAAJ,CAAU,GAAV,CAAV;AACzB,GAFD;AAGA,SAAOZ,OAAP;AACA,CAND;;AAQA,MAAMK,UAAU,GAAIY,eAAD,IAA+B;AACjD,MAAIC,QAAJ;AACA,MAAIC,aAAa,GAAGC,oBAAoB,CAACH,eAAD,CAAxC;AAEAC,EAAAA,QAAQ,GAAGC,aAAX,CAJiD,CAIvB;;AAC1B,SAAOD,QAAP;AACA,CAND,C,CAQA;;;AACA,MAAME,oBAAoB,GAAIH,eAAD,IAA+B;AAC3D,MAAII,MAAkB,GAAG,EAAzB;AACA,MAAIC,YAAY,GAAG,CAAnB;AACA,MAAIC,WAAW,GAAG,CAAlB;AACA,MAAIC,aAAa,GAAGC,YAAY,CAACR,eAAD,CAAhC;AACAO,EAAAA,aAAa,CAACV,OAAd,CAAsB,CAACC,GAAD,EAAMW,CAAN,KAAY;AACjC,QAAIX,GAAG,CAACY,UAAJ,CAAe,KAAf,KAAyBZ,GAAG,CAACC,QAAJ,CAAa,KAAb,CAA7B,EAAkD;AACjD,UAAIM,YAAY,KAAK,CAArB,EAAwB;AACvBA,QAAAA,YAAY,GAAGI,CAAf;AACAH,QAAAA,WAAW,GAAGG,CAAC,GAAG,CAAlB,CAFuB,CAGvB;AACA,OAJD,MAIO,IAAIA,CAAC,GAAGH,WAAJ,GAAkB,CAAtB,EAAyB;AAC/BD,QAAAA,YAAY,GAAGI,CAAf;AACAL,QAAAA,MAAM,CAACO,IAAP,CAAYX,eAAe,CAACY,KAAhB,CAAsBN,WAAtB,EAAmCD,YAAnC,CAAZ;AACAC,QAAAA,WAAW,GAAGG,CAAC,GAAG,CAAlB;AACA;AACD;AACD,GAZD;AAaA,SAAOL,MAAP;AACA,CAnBD,C,CAqBA;;;AACA,MAAMI,YAAY,GAAIR,eAAD,IAA+B;AACnD,MAAIO,aAAa,GAAGP,eAAe,CAACa,MAAhB,CAClBf,GAAD,IACCA,GAAG,CAACY,UAAJ,CAAe,KAAf,KACAZ,GAAG,CAACY,UAAJ,CAAe,KAAf,CADA,IAEAZ,GAAG,CAACY,UAAJ,CAAe,KAAf,CAFA,IAGAZ,GAAG,CAACY,UAAJ,CAAe,KAAf,CALkB,CAApB;AAOA,SAAOH,aAAP;AACA,CATD,C,CAWA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA","sourcesContent":["export const convertXml = (dataFromForm: string) => {\n\tlet headers = getHeaders(formToArray(dataFromForm) || []);\n\tconsole.log(toCSVarray(formToArray(dataFromForm) || []));\n};\n\nconst formToArray = (dataFromForm: string) => {\n\tvar xmlParser = new DOMParser();\n\tvar xmlDoc = xmlParser.parseFromString(dataFromForm, \"text/xml\");\n\treturn xmlDoc\n\t\t.getElementsByTagName(\"CSVIntervalData\")[0]\n\t\t.textContent?.split(\"\\n\");\n};\n\n//get the header row which contains 100\nconst getHeaders = (xmlDocArr: string[]) => {\n\tlet headers;\n\txmlDocArr.forEach((row) => {\n\t\tif (row.includes(\"100\")) headers = row.split(\",\");\n\t});\n\treturn headers;\n};\n\nconst toCSVarray = (unformattedRows: string[]) => {\n\tlet CSVArray;\n\tlet seperatedData = seperateRowsToChunks(unformattedRows);\n\n\tCSVArray = seperatedData; //to be changed\n\treturn CSVArray;\n};\n\n//seperate the rows by the line which contains 200\nconst seperateRowsToChunks = (unformattedRows: string[]) => {\n\tlet chunks: string[][] = [];\n\tlet quickPointer = 0;\n\tlet slowPointer = 0;\n\tlet validatedRows = validateRows(unformattedRows);\n\tvalidatedRows.forEach((row, i) => {\n\t\tif (row.startsWith(\"200\") || row.includes(\"900\")) {\n\t\t\tif (quickPointer === 0) {\n\t\t\t\tquickPointer = i;\n\t\t\t\tslowPointer = i + 1;\n\t\t\t\t// to make sure it contains at least 1 row for each 200\n\t\t\t} else if (i - slowPointer > 1) {\n\t\t\t\tquickPointer = i;\n\t\t\t\tchunks.push(unformattedRows.slice(slowPointer, quickPointer));\n\t\t\t\tslowPointer = i + 1;\n\t\t\t}\n\t\t}\n\t});\n\treturn chunks;\n};\n\n//to check whether the row is validate\nconst validateRows = (unformattedRows: string[]) => {\n\tlet validatedRows = unformattedRows.filter(\n\t\t(row) =>\n\t\t\trow.startsWith(\"100\") ||\n\t\t\trow.startsWith(\"200\") ||\n\t\t\trow.startsWith(\"300\") ||\n\t\t\trow.startsWith(\"900\")\n\t);\n\treturn validatedRows;\n};\n\n// var A = [[\"n\", \"sqrt(n)\"]];\n// for (var j: number = 1; j < 10; ++j) {\n// \tA.push([j.toString(), Math.sqrt(j).toString()]);\n// }\n// var csvRows = [];\n\n// for (var i = 0, l = A.length; i < l; ++i) {\n// \tcsvRows.push(A[i].join(\",\"));\n// }\n\n// var csvString = csvRows.join(\"%0A\");\n// var a = document.createElement(\"a\");\n// a.href = \"data:attachment/csv,\" + encodeURIComponent(csvString);\n// a.target = \"_blank\";\n// a.download = \"myFile.csv\";\n\n// document.body.appendChild(a);\n// a.click();\n"]},"metadata":{},"sourceType":"module"}