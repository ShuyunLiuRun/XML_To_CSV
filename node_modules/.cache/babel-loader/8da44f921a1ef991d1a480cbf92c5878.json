{"ast":null,"code":"var sharedHeaders = \"\";\nvar sharedTailer = \"\";\nexport const convertXml = dataFromForm => {\n  let unformattedArray = formToArray(dataFromForm) || [];\n  sharedHeaders = getHeaders(unformattedArray) || \"\";\n  sharedTailer = getTailer(unformattedArray) || \"\";\n  toCSVArraies(unformattedArray).forEach(eachCSV => {\n    let fileName = getFileName(eachCSV);\n    let csvString = eachCSV.join(\"\\n\");\n    var a = document.createElement(\"a\");\n    a.href = \"data:attachment/csv,\" + encodeURIComponent(csvString);\n    a.target = \"_blank\";\n    a.download = `${fileName}.csv`;\n    document.body.appendChild(a);\n    a.click();\n  });\n};\n\nconst getFileName = eachCSV => {\n  return eachCSV[1].split(\",\")[1];\n}; // push each row of the xml into an array\n\n\nconst formToArray = dataFromForm => {\n  var _xmlDoc$getElementsBy;\n\n  var xmlParser = new DOMParser();\n  var xmlDoc = xmlParser.parseFromString(dataFromForm, \"text/xml\");\n  return (_xmlDoc$getElementsBy = xmlDoc.getElementsByTagName(\"CSVIntervalData\")[0].textContent) === null || _xmlDoc$getElementsBy === void 0 ? void 0 : _xmlDoc$getElementsBy.split(\"\\n\");\n}; //get the header row which start with 100\n\n\nconst getHeaders = xmlDocArr => {\n  let headers;\n  xmlDocArr.forEach(row => {\n    if (row.startsWith(\"100\")) headers = row;\n  });\n  return headers;\n}; //get the tailer row that start with 900\n\n\nconst getTailer = xmlDocArr => {\n  let tailer;\n  xmlDocArr.forEach(row => {\n    if (row.startsWith(\"900\")) tailer = row;\n  });\n  return tailer;\n};\n\nexport const toCSVArraies = unformattedRows => {\n  console.log(unformattedRows);\n  let CSVArraies = []; //seperate the chunks by the \"200\"\n\n  let seperatedData = seperateRowsToChunks(unformattedRows);\n  seperatedData.forEach(chunk => {\n    let eachCSV = [sharedHeaders];\n    chunk.forEach(row => {\n      //remove the comma in the end\n      row.charAt(row.length - 1) === \",\" ? eachCSV.push(row.substring(0, row.length - 1)) : eachCSV.push(row);\n    });\n    eachCSV.push(sharedTailer);\n    CSVArraies.push(eachCSV);\n  });\n  return CSVArraies;\n}; //seperate the rows by the line which contains 200\n\nconst seperateRowsToChunks = unformattedRows => {\n  let chunks = [];\n  let quickPointer = 0;\n  let slowPointer = 0;\n  let validatedRows = validateRows(unformattedRows);\n  validatedRows.forEach((row, i) => {\n    if (row.startsWith(\"200\") || row.includes(\"900\")) {\n      if (quickPointer === 0) {\n        quickPointer = i + 1;\n        slowPointer = i + 1;\n      } else {\n        quickPointer = i + 1;\n        chunks.push(unformattedRows.slice(slowPointer, quickPointer));\n        slowPointer = i + 1;\n      }\n    }\n  });\n  return chunks;\n}; //to check whether the rows are validate\n\n\nconst validateRows = unformattedRows => {\n  const validateOneRowForEach = unformattedRows => {\n    let one = false;\n    let two = false;\n    let three = false;\n    let nine = false;\n    unformattedRows.forEach(row => {\n      if (row.startsWith(\"100\")) one = true;\n      if (row.startsWith(\"200\")) two = true;\n      if (row.startsWith(\"300\")) three = true;\n      if (row.startsWith(\"900\")) nine = true;\n    });\n    return one && two && three && nine;\n  };\n\n  const validateOnlyAppearOnce = unformattedRows => {\n    let one = 0;\n    let nine = 0;\n    unformattedRows.forEach(row => {\n      if (row.startsWith(\"100\")) one += 1;\n      if (row.startsWith(\"900\")) nine += 1;\n    });\n    return one === 1 && nine === 1;\n  };\n\n  try {\n    if (validateOneRowForEach(unformattedRows) === false) {\n      throw new Error('The CSVIntervalData element should contain at least 1 row for each of \"100\", \"200\", \"300\",\"900\"');\n    }\n\n    if (validateOnlyAppearOnce(unformattedRows)) {}\n  } catch (e) {\n    console.error(e);\n  }\n\n  if (validateOneRowForEach(unformattedRows)) throw new Error('The CSVIntervalData element should contain at least 1 row for each of \"100\", \"200\", \"300\",\"900\"');\n  if (validateOnlyAppearOnce(unformattedRows)) throw new Error(\"'100', '900' rows should only appear once inside the CSVIntervalData element\");\n  let validatedRows = unformattedRows.filter(row => row.startsWith(\"100\") || row.startsWith(\"200\") || row.startsWith(\"300\") || row.startsWith(\"900\"));\n  return validatedRows;\n};","map":{"version":3,"sources":["/Users/shuyun/Desktop/vscode/xml-to-csv/UI/src/services/convertXml.tsx"],"names":["sharedHeaders","sharedTailer","convertXml","dataFromForm","unformattedArray","formToArray","getHeaders","getTailer","toCSVArraies","forEach","eachCSV","fileName","getFileName","csvString","join","a","document","createElement","href","encodeURIComponent","target","download","body","appendChild","click","split","xmlParser","DOMParser","xmlDoc","parseFromString","getElementsByTagName","textContent","xmlDocArr","headers","row","startsWith","tailer","unformattedRows","console","log","CSVArraies","seperatedData","seperateRowsToChunks","chunk","charAt","length","push","substring","chunks","quickPointer","slowPointer","validatedRows","validateRows","i","includes","slice","validateOneRowForEach","one","two","three","nine","validateOnlyAppearOnce","Error","e","error","filter"],"mappings":"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","sourcesContent":["var sharedHeaders: string = \"\";\nvar sharedTailer: string = \"\";\n\nexport const convertXml = (dataFromForm: string) => {\n\tlet unformattedArray = formToArray(dataFromForm) || [];\n\tsharedHeaders = getHeaders(unformattedArray) || \"\";\n\tsharedTailer = getTailer(unformattedArray) || \"\";\n\n\ttoCSVArraies(unformattedArray).forEach((eachCSV: string[]) => {\n\t\tlet fileName = getFileName(eachCSV);\n\n\t\tlet csvString = eachCSV.join(\"\\n\");\n\n\t\tvar a = document.createElement(\"a\");\n\t\ta.href = \"data:attachment/csv,\" + encodeURIComponent(csvString);\n\t\ta.target = \"_blank\";\n\t\ta.download = `${fileName}.csv`;\n\n\t\tdocument.body.appendChild(a);\n\t\ta.click();\n\t});\n};\n\nconst getFileName = (eachCSV: string[]) => {\n\treturn eachCSV[1].split(\",\")[1];\n};\n\n// push each row of the xml into an array\nconst formToArray = (dataFromForm: string) => {\n\tvar xmlParser = new DOMParser();\n\tvar xmlDoc = xmlParser.parseFromString(dataFromForm, \"text/xml\");\n\treturn xmlDoc\n\t\t.getElementsByTagName(\"CSVIntervalData\")[0]\n\t\t.textContent?.split(\"\\n\");\n};\n\n//get the header row which start with 100\nconst getHeaders = (xmlDocArr: string[]) => {\n\tlet headers;\n\txmlDocArr.forEach((row) => {\n\t\tif (row.startsWith(\"100\")) headers = row;\n\t});\n\treturn headers;\n};\n\n//get the tailer row that start with 900\nconst getTailer = (xmlDocArr: string[]) => {\n\tlet tailer;\n\txmlDocArr.forEach((row) => {\n\t\tif (row.startsWith(\"900\")) tailer = row;\n\t});\n\treturn tailer;\n};\n\nexport const toCSVArraies = (unformattedRows: string[]) => {\n\tconsole.log(unformattedRows);\n\n\tlet CSVArraies: string[][] = [];\n\t//seperate the chunks by the \"200\"\n\tlet seperatedData = seperateRowsToChunks(unformattedRows);\n\tseperatedData.forEach((chunk) => {\n\t\tlet eachCSV: string[] = [sharedHeaders];\n\t\tchunk.forEach((row) => {\n\t\t\t//remove the comma in the end\n\t\t\trow.charAt(row.length - 1) === \",\"\n\t\t\t\t? eachCSV.push(row.substring(0, row.length - 1))\n\t\t\t\t: eachCSV.push(row);\n\t\t});\n\t\teachCSV.push(sharedTailer);\n\t\tCSVArraies.push(eachCSV);\n\t});\n\treturn CSVArraies;\n};\n\n//seperate the rows by the line which contains 200\nconst seperateRowsToChunks = (unformattedRows: string[]) => {\n\tlet chunks: string[][] = [];\n\tlet quickPointer = 0;\n\tlet slowPointer = 0;\n\n\tlet validatedRows = validateRows(unformattedRows);\n\tvalidatedRows.forEach((row, i) => {\n\t\tif (row.startsWith(\"200\") || row.includes(\"900\")) {\n\t\t\tif (quickPointer === 0) {\n\t\t\t\tquickPointer = i + 1;\n\t\t\t\tslowPointer = i + 1;\n\t\t\t} else {\n\t\t\t\tquickPointer = i + 1;\n\t\t\t\tchunks.push(unformattedRows.slice(slowPointer, quickPointer));\n\t\t\t\tslowPointer = i + 1;\n\t\t\t}\n\t\t}\n\t});\n\treturn chunks;\n};\n\n//to check whether the rows are validate\nconst validateRows = (unformattedRows: string[]) => {\n\tconst validateOneRowForEach = (unformattedRows: string[]) => {\n\t\tlet one = false;\n\t\tlet two = false;\n\t\tlet three = false;\n\t\tlet nine = false;\n\t\tunformattedRows.forEach((row) => {\n\t\t\tif (row.startsWith(\"100\")) one = true;\n\t\t\tif (row.startsWith(\"200\")) two = true;\n\t\t\tif (row.startsWith(\"300\")) three = true;\n\t\t\tif (row.startsWith(\"900\")) nine = true;\n\t\t});\n\t\treturn one && two && three && nine;\n\t};\n\n\tconst validateOnlyAppearOnce = (unformattedRows: string[]) => {\n\t\tlet one = 0;\n\t\tlet nine = 0;\n\t\tunformattedRows.forEach((row) => {\n\t\t\tif (row.startsWith(\"100\")) one += 1;\n\t\t\tif (row.startsWith(\"900\")) nine += 1;\n\t\t});\n\t\treturn one === 1 && nine === 1;\n\t};\n\n\ttry {\n\t\tif (validateOneRowForEach(unformattedRows) === false) {\n\t\t\tthrow new Error(\n\t\t\t\t'The CSVIntervalData element should contain at least 1 row for each of \"100\", \"200\", \"300\",\"900\"'\n\t\t\t);\n\t\t}\n\t\tif (validateOnlyAppearOnce(unformattedRows)) {\n\t\t}\n\t} catch (e) {\n\t\tconsole.error(e);\n\t}\n\tif (validateOneRowForEach(unformattedRows))\n\t\tthrow new Error(\n\t\t\t'The CSVIntervalData element should contain at least 1 row for each of \"100\", \"200\", \"300\",\"900\"'\n\t\t);\n\tif (validateOnlyAppearOnce(unformattedRows))\n\t\tthrow new Error(\n\t\t\t\"'100', '900' rows should only appear once inside the CSVIntervalData element\"\n\t\t);\n\n\tlet validatedRows = unformattedRows.filter(\n\t\t(row) =>\n\t\t\trow.startsWith(\"100\") ||\n\t\t\trow.startsWith(\"200\") ||\n\t\t\trow.startsWith(\"300\") ||\n\t\t\trow.startsWith(\"900\")\n\t);\n\treturn validatedRows;\n};\n"]},"metadata":{},"sourceType":"module"}