{"ast":null,"code":"var sharedHeaders = \"\";\nvar sharedTailer = \"\";\nexport const convertXml = dataFromForm => {\n  let unformattedArray = formToArray(dataFromForm) || [];\n  sharedHeaders = getHeaders(unformattedArray) || \"\";\n  sharedTailer = getTailer(formToArray(dataFromForm) || []) || \"\";\n  console.log(sharedHeaders, toCSVarraies(formToArray(dataFromForm) || []));\n  var csvRows = [];\n\n  for (var i = 0, l = A.length; i < l; ++i) {\n    csvRows.push(A[i].join(\",\"));\n  }\n\n  var csvString = csvRows.join(\"%0A\");\n  var a = document.createElement(\"a\");\n  a.href = \"data:attachment/csv,\" + encodeURIComponent(csvString);\n  a.target = \"_blank\";\n  a.download = \"myFile.csv\";\n  document.body.appendChild(a);\n  a.click();\n};\n\nconst formToArray = dataFromForm => {\n  var _xmlDoc$getElementsBy;\n\n  var xmlParser = new DOMParser();\n  var xmlDoc = xmlParser.parseFromString(dataFromForm, \"text/xml\");\n  return (_xmlDoc$getElementsBy = xmlDoc.getElementsByTagName(\"CSVIntervalData\")[0].textContent) === null || _xmlDoc$getElementsBy === void 0 ? void 0 : _xmlDoc$getElementsBy.split(\"\\n\");\n}; //get the header row which start with 100\n\n\nconst getHeaders = xmlDocArr => {\n  let headers;\n  xmlDocArr.forEach(row => {\n    if (row.startsWith(\"100\")) headers = row;\n  });\n  return headers;\n}; //get the tailer row that start with 900\n\n\nconst getTailer = xmlDocArr => {\n  let tailer;\n  xmlDocArr.forEach(row => {\n    if (row.startsWith(\"900\")) tailer = row;\n  });\n  return tailer;\n};\n\nconst toCSVarraies = unformattedRows => {\n  let CSVArraies = [];\n  let seperatedData = seperateRowsToChunks(unformattedRows);\n  seperatedData.forEach(chunk => {\n    CSVArraies.push([sharedHeaders].concat(chunk).concat(sharedTailer));\n  });\n  return CSVArraies;\n}; //seperate the rows by the line which contains 200\n\n\nconst seperateRowsToChunks = unformattedRows => {\n  let chunks = [];\n  let quickPointer = 0;\n  let slowPointer = 0;\n  let validatedRows = validateRows(unformattedRows);\n  validatedRows.forEach((row, i) => {\n    if (row.startsWith(\"200\") || row.includes(\"900\")) {\n      if (quickPointer === 0) {\n        quickPointer = i + 1;\n        slowPointer = i + 1; // to make sure it contains at least 1 row for each 200\n      } else if (i - slowPointer > 1) {\n        quickPointer = i + 1;\n        chunks.push(unformattedRows.slice(slowPointer, quickPointer));\n        slowPointer = i + 1;\n      }\n    }\n  });\n  return chunks;\n}; //to check whether the row is validate\n\n\nconst validateRows = unformattedRows => {\n  let validatedRows = unformattedRows.filter(row => row.startsWith(\"100\") || row.startsWith(\"200\") || row.startsWith(\"300\") || row.startsWith(\"900\"));\n  return validatedRows;\n};","map":{"version":3,"sources":["/Users/shuyun/Desktop/vscode/xml-to-csv/UI/src/services/convertXml.tsx"],"names":["sharedHeaders","sharedTailer","convertXml","dataFromForm","unformattedArray","formToArray","getHeaders","getTailer","console","log","toCSVarraies","csvRows","i","l","A","length","push","join","csvString","a","document","createElement","href","encodeURIComponent","target","download","body","appendChild","click","xmlParser","DOMParser","xmlDoc","parseFromString","getElementsByTagName","textContent","split","xmlDocArr","headers","forEach","row","startsWith","tailer","unformattedRows","CSVArraies","seperatedData","seperateRowsToChunks","chunk","concat","chunks","quickPointer","slowPointer","validatedRows","validateRows","includes","slice","filter"],"mappings":"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","sourcesContent":["var sharedHeaders: string = \"\";\nvar sharedTailer: string = \"\";\n\nexport const convertXml = (dataFromForm: string) => {\n\tlet unformattedArray: string[] = formToArray(dataFromForm) || [];\n\tsharedHeaders = getHeaders(unformattedArray) || \"\";\n\tsharedTailer = getTailer(formToArray(dataFromForm) || []) || \"\";\n\tconsole.log(sharedHeaders, toCSVarraies(formToArray(dataFromForm) || []));\n\n\tvar csvRows = [];\n\n\tfor (var i = 0, l = A.length; i < l; ++i) {\n\t\tcsvRows.push(A[i].join(\",\"));\n\t}\n\n\tvar csvString = csvRows.join(\"%0A\");\n\tvar a = document.createElement(\"a\");\n\ta.href = \"data:attachment/csv,\" + encodeURIComponent(csvString);\n\ta.target = \"_blank\";\n\ta.download = \"myFile.csv\";\n\n\tdocument.body.appendChild(a);\n\ta.click();\n};\n\nconst formToArray = (dataFromForm: string) => {\n\tvar xmlParser = new DOMParser();\n\tvar xmlDoc = xmlParser.parseFromString(dataFromForm, \"text/xml\");\n\treturn xmlDoc\n\t\t.getElementsByTagName(\"CSVIntervalData\")[0]\n\t\t.textContent?.split(\"\\n\");\n};\n\n//get the header row which start with 100\nconst getHeaders = (xmlDocArr: string[]) => {\n\tlet headers;\n\txmlDocArr.forEach((row) => {\n\t\tif (row.startsWith(\"100\")) headers = row;\n\t});\n\treturn headers;\n};\n\n//get the tailer row that start with 900\nconst getTailer = (xmlDocArr: string[]) => {\n\tlet tailer;\n\txmlDocArr.forEach((row) => {\n\t\tif (row.startsWith(\"900\")) tailer = row;\n\t});\n\treturn tailer;\n};\n\nconst toCSVarraies = (unformattedRows: string[]) => {\n\tlet CSVArraies: string[][] = [];\n\tlet seperatedData = seperateRowsToChunks(unformattedRows);\n\tseperatedData.forEach((chunk) => {\n\t\tCSVArraies.push([sharedHeaders].concat(chunk).concat(sharedTailer));\n\t});\n\treturn CSVArraies;\n};\n\n//seperate the rows by the line which contains 200\nconst seperateRowsToChunks = (unformattedRows: string[]) => {\n\tlet chunks: string[][] = [];\n\tlet quickPointer = 0;\n\tlet slowPointer = 0;\n\tlet validatedRows = validateRows(unformattedRows);\n\tvalidatedRows.forEach((row, i) => {\n\t\tif (row.startsWith(\"200\") || row.includes(\"900\")) {\n\t\t\tif (quickPointer === 0) {\n\t\t\t\tquickPointer = i + 1;\n\t\t\t\tslowPointer = i + 1;\n\t\t\t\t// to make sure it contains at least 1 row for each 200\n\t\t\t} else if (i - slowPointer > 1) {\n\t\t\t\tquickPointer = i + 1;\n\t\t\t\tchunks.push(unformattedRows.slice(slowPointer, quickPointer));\n\t\t\t\tslowPointer = i + 1;\n\t\t\t}\n\t\t}\n\t});\n\treturn chunks;\n};\n\n//to check whether the row is validate\nconst validateRows = (unformattedRows: string[]) => {\n\tlet validatedRows = unformattedRows.filter(\n\t\t(row) =>\n\t\t\trow.startsWith(\"100\") ||\n\t\t\trow.startsWith(\"200\") ||\n\t\t\trow.startsWith(\"300\") ||\n\t\t\trow.startsWith(\"900\")\n\t);\n\treturn validatedRows;\n};\n"]},"metadata":{},"sourceType":"module"}